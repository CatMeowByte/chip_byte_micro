extends Node
class_name CBMCore

const FONT_SMALL: Array[int] = [ # 3x5
	0xE0, 0xA0, 0xA0, 0xA0, 0xE0, # 0
	0xC0, 0x40, 0x40, 0x40, 0xE0, # 1
	0xE0, 0x20, 0xE0, 0x80, 0xE0, # 2
	0xE0, 0x20, 0xE0, 0x20, 0xE0, # 3
	0xA0, 0xA0, 0xE0, 0x20, 0x20, # 4
	0xE0, 0x80, 0xE0, 0x20, 0xE0, # 5
	0xE0, 0x80, 0xE0, 0xA0, 0xE0, # 6
	0xE0, 0x20, 0x40, 0x40, 0x40, # 7
	0xE0, 0xA0, 0xE0, 0xA0, 0xE0, # 8
	0xE0, 0xA0, 0xE0, 0x20, 0xE0, # 9
	0xE0, 0xA0, 0xE0, 0xA0, 0xA0, # A
	0xC0, 0xA0, 0xE0, 0xA0, 0xC0, # B
	0xE0, 0x80, 0x80, 0x80, 0xE0, # C
	0xC0, 0xA0, 0xA0, 0xA0, 0xC0, # D
	0xE0, 0x80, 0xE0, 0x80, 0xE0, # E
	0xE0, 0x80, 0xE0, 0x80, 0x80  # F
]
const FONT_LARGE: Array[int] = [ # 7x9
	0x7C, 0xC6, 0xCE, 0xDE, 0xD6, 0xF6, 0xE6, 0xC6, 0x7C, 0x00, # 0
	0x10, 0x30, 0xF0, 0x30, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00, # 1
	0x78, 0xCC, 0xCC, 0x0C, 0x18, 0x30, 0x60, 0xCC, 0xFC, 0x00, # 2
	0x78, 0xCC, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0xCC, 0x78, 0x00, # 3
	0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x1E, 0x00, # 4
	0xFC, 0xC0, 0xC0, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00, # 5
	0x38, 0x60, 0xC0, 0xC0, 0xF8, 0xCC, 0xCC, 0xCC, 0x78, 0x00, # 6
	0xFE, 0xC6, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00, # 7
	0x78, 0xCC, 0xCC, 0xEC, 0x78, 0xDC, 0xCC, 0xCC, 0x78, 0x00, # 8
	0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x18, 0x18, 0x30, 0x70, 0x00, # 9
	0x30, 0x78, 0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00, # A
	0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0xFC, 0x00, # B
	0x3C, 0x66, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x66, 0x3C, 0x00, # C
	0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, # D
	0xFE, 0x62, 0x60, 0x64, 0x7C, 0x64, 0x60, 0x62, 0xFE, 0x00, # E
	0xFE, 0x66, 0x62, 0x64, 0x7C, 0x64, 0x60, 0x60, 0xF0, 0x00, # F
]

var video: Dictionary[String, int] = {
	width = 64,
	height = 32,
}
var flags: Dictionary[String, bool] = {
	is_halting = false,
	is_awaiting_key = false,
	is_hires = false,
}

var memory: PackedByteArray # 4096 byte
var buffer: PackedByteArray # should be 256 byte but 2048 for convenience
var register: PackedByteArray # 16 byte
var storage: PackedByteArray # 16 byte
var stack: PackedInt32Array # should be 16 * 2 byte but only exist int32

var delay: int = 0 # 1 byte
var sound: int = 0 # 1 byte

var counter: int = 0 # 2 byte
var pointer: int = 0 # 2 byte


func init() -> void:
	set_hires(false)

	memory.resize(4096)
	buffer.resize(128 * 64)
	register.resize(16)
	storage.resize(16)
	stack.resize(16)

	memory.fill(0)
	buffer.fill(0)
	register.fill(0)
	stack.fill(0)

	delay = 0
	sound = 0
	counter = 0x0FFE
	pointer = 0

	# Load font
	for i: int in FONT_SMALL.size():
		memory[0x50 + i] = FONT_SMALL[i]
	for i: int in FONT_LARGE.size():
		memory[0xA0 + i] = FONT_LARGE[i]


func cartridge_load(path: String) -> void:
	if not path.to_lower().ends_with(".ch8"):
		printerr("CARTRIDGE INVALID: ", path)
		return

	init()

	var cartridge: FileAccess = FileAccess.open(path, FileAccess.READ)
	if not cartridge: return

	pointer = 0x200
	while not cartridge.eof_reached():
		if pointer >= memory.size():
			printerr("CARTRIDGE LOAD MEMORY OVERFLOW")
			break
		memory[pointer] = cartridge.get_8()
		pointer += 1

	counter = 0x200
	print("CARTRIDGE LOADED: ", path)


func execute() -> void:
	if counter < 0 or counter + 1 >= memory.size():
		printerr("COUNTER OUT OF BOUNDS: ", counter)
		return

	var opcode: int = memory[counter] << 8 | memory[counter + 1]
	var result: Dictionary[String, bool] = {}

	if opcode: # For 0x0000 NOP
		match opcode & 0xF000:
			0x0000: result = Opcode0.execute(self, opcode)
			0x1000: result = Opcode1.execute(self, opcode)
			0x2000: result = Opcode2.execute(self, opcode)
			0x3000: result = Opcode3.execute(self, opcode)
			0x4000: result = Opcode4.execute(self, opcode)
			0x5000: result = Opcode5.execute(self, opcode)
			0x6000: result = Opcode6.execute(self, opcode)
			0x7000: result = Opcode7.execute(self, opcode)
			0x8000: result = Opcode8.execute(self, opcode)
			0x9000: result = Opcode9.execute(self, opcode)
			0xA000: result = OpcodeA.execute(self, opcode)
			0xB000: result = OpcodeB.execute(self, opcode)
			0xC000: result = OpcodeC.execute(self, opcode)
			0xD000: result = OpcodeD.execute(self, opcode)
			0xE000: result = OpcodeE.execute(self, opcode)
			0xF000: result = OpcodeF.execute(self, opcode)
			_: result.valid = false

	if not result.get("valid", true): printerr("OPCODE INVALID: 0x%04X" % opcode)
	if result.get("increment", true): counter += 2 # 2 byte opcode size
	counter = clampi(counter, 0, 4096 - 2)


func state_update() -> void:
	delay = maxi(0 , delay - 1)
	sound = maxi(0 , sound - 1)
	flags.is_halting = false


func set_hires(enable: bool = false) -> void:
	flags.is_hires = enable
	video.width = 128 if flags.is_hires else 64
	video.height = 64 if flags.is_hires else 32
